/** \struct lua_State
	\brief Lua virtual machine
	\details
	Taken from Lua manual :
	An opaque structure that points to a thread and indirectly (through the thread) 
	to the whole state of a Lua interpreter. The Lua library is fully reentrant: it 
	has no global variables. All information about a state is accessible through this 
	structure.
*/

/**
	\addtogroup OOLuaKnownLimitations Known limitations
	@{
	@}
*/

/**
	\addtogroup OOLuaConfig Library Configuration
	@{
		\details OOLua is easily configurable in two areas errors( \ref OOLuaErrorReporting , \ref OOLuaErrorChecking )
		and limits ( \ref OOLuaFileGeneration ).
	 	\addtogroup OOLuaFileGeneration File Generation
		@{
		@}
	@}
*/


/** 
\page OOLuaUseage Usage 
\brief

	Most if not all of the code snippets shown in this document are working pieces of code taken directly from the \ref OOLuaTestFiles "unit test files", as such the code is always correct although it may at times not marry up to the text which surrounds it in this documentation. If you should see such a thing please report it on the \ref OOLuaLinks "issue tracker".
	<p>
	\li \subpage OOLuaFirstLook
	\li \subpage LuaTypesInOOLua
	\li \subpage OOLuaProxying
	<p>
*/


/**
\page OOLuaFirstLook First look
 
	\section HelloMoon Hello Moon
		\snippet hello_moon.cpp HelloMoonCFuncAndProxy
		\snippet hello_moon.cpp HelloMoonCFuncAndProxyMinimalist
		\snippet hello_moon.cpp HelloMoonCFuncAndProxyMinimalistUsage

	\section OOLuaConventions Conventions
		\li \ref OOLuaDSL macros are upper case and prefixed with OOLUA_
		\li \ref OOLuaMinimalist DSL macro names are smaller than \ref OOLuaExpressive
		\li Public API functions and types are directly in the OOLUA namespace
		\li Public API function names are lower case with words separated by underscores
 		<p>

 	\section OOLuaLuaStateAndScript lua_State and Script
 		\copydetails OOLUA::Script
 		
	\section OOLuaAndTheStack OOLua and the Lua stack
		The Lua C API does not force you to treat the stack as such a data structure
		with operations on just one end, instead for convenience it uses indices to
		identify stack slots for a procedure. Given that it is a C API without C++'s name
		mangling and overloading it also provides a function per type for pushing to the
		stack. 
		<p>
		OOLua tries to enforce a clean stack after operations as such it provides a simple
		interface to the Lua stack which consists of two functions :
			\arg \ref OOLUA::push "push" \copybrief OOLUA::push
			\arg \ref OOLUA::pull "pull" \copybrief OOLUA::pull
 		<p>
 		Most usage of OOLua will only require these functions to interact with the stack
 		yet you are free to mix Lua C API calls if you take into account \ref OOLUA::pull
 		"pull" removes top when it is valid.
 		
 */
 
 /**
 \page LuaTypesInOOLua Lua Types in OOLua
 	\brief OOLua has three types to help interact with Lua types
 	\section OOLuaTypesRef Lua_ref 
 		\copydetails OOLUA::Lua_ref
 		For your connivence there are two predefined typedefs:
 		\li \ref OOLUA::Lua_func_ref
 		\snippet exchange_lua2cpp.cpp FunctionReferencePullSetup
 		\snippet exchange_lua2cpp.cpp FunctionReferencePull
 			
 		\li \ref OOLUA::Lua_table_ref
 		\snippet exchange_lua2cpp.cpp PullingTableRefOffTheStack
 			
 	\section OOLuaTypesFunction Lua_function 
 		\copydetails OOLUA::Lua_function
 			\subsection CallingALuaFunction Calling a Lua function
			A Lua function can be called using the function object 
			\ref OOLUA::Lua_function of which there is an instance bound in the 
			constructor for Script \ref OOLUA::Script::call. Lua_function has 
			overloaded function call operators which take upto the maximum 
			defined OOLuaConfigLuaParams "\"lua_params\"".\n
		
			Name:
			\snippet lua_caller.cpp CallingFunctionByGlobalName
			Lua_func_ref:
			\snippet lua_caller.cpp CallingFunctionByFuncRef
			Valid stack index
			\snippet lua_caller.cpp CallingFunctionByValidStackIndex
		
 	 \section OOLuaTypesTable Table 
 		\copydetails OOLUA::Table
 		<p>There are two helper functions for creating a \ref OOLUA::Table both of
 		which are named \ref OOLUA::new_table.
 		\snippet table.cpp OOLuaTableAtExample
*/

/*
			\subsubsection ClassTags Tags
				\copydetails OOLUA_TAGS

			\subsubsection ClassExporting Exporting
				\copydetails OOLuaExporting

*/



/**
\page OOLuaProxying Proxy
	\section OOLuaProxyDSL DSL
			\copybrief OOLuaDSL 
			\copydetails OOLuaDSL
			<p>\ref OOLuaMinimalist
			\copydetails OOLuaMinimalist
			<p>\ref OOLuaExpressive
			\copydetails OOLuaExpressive
		

	\section OOLuaProxyTraits Traits
		\copydetails OOLuaTraits

	\section ClassProxy Class Proxy
		Generating a proxy for a class normally takes place between two DSL procedures 
		\ref OOLUA_PROXY and \ref OOLUA_PROXY_END although alone these do not supply 
		enough information for a proxy to be generated, the following shows the usage
		of the DSL to proxy and use a C++ class in Lua.

		\subsection MinimalClassProxy Minimal Class Proxy
			\snippet cpp_stub_classes.h UsedAsMinimalClass
			To proxy a class and be able to use it in Lua requires a three part process. 
			<p>
				\subsubsection ProxyBlock Proxy Block
				Firstly you create a proxy block which starts with a OOLUA_PROXY call to which 
				you pass the name of the C++ class to be proxied, this block ends at the next
				OOLUA_PROXY_END. Soon we will see how to proxy other aspects of a class in this
				block.
				\snippet expose_stub_classes.h MinimalProxyClass
			<p>
				\subsubsection ClassExporting Exporting
				Secondly export member functions which are to be available to Lua for the type.
				\copydetails OOLuaExporting
				<p>		
				\snippet expose_stub_classes.cpp MinimalProxyExport
			<p>
				\subsubsection ClassRegistering Registering 
				Lastly we register the type with a lua_State after which the type can be \ref DefaultConstructor "created" 
				and used in Lua.
				\snippet construct.cpp MinimalProxyClassRegister
				<p>
				\snippet construct.cpp MinimalProxyClassUsage
			<p>

		\subsection ProxyTags Tags
			\copydetails OOLUA_TAGS

		\subsection DefaultConstructor Default Constructor
			The default class constructor is a special member function like C++ and it will 
			be impliclty defined for a type unless \ref OOLuaTags "otherwise specified". When 
			available for a type "foo" in can be called in Lua using the following syntax.
			\code{.lua}
				foo.new()
			\endcode
			\see OOLUA::Abstract OOLUA::No_default_constructor OOLUA::No_public_constructors
		
		\subsection ClassConstructors Constructors	
			<p>
			\copydetails OOLUA_CTORS
			<p>
			\snippet expose_class_constructors.h ExposeConstructors
 
		\subsection ExposingMemberFunctions Exposing Member Functions
			\copydetails OOLUA_MFUNC
			\copydetails OOLUA_MFUNC_CONST
			\snippet expose_vector_int.h StdVectorProxy
			\snippet expose_vector_int.cpp StdVectorProxyExport

		\subsection AbstractClass Abstract Class
			Generating an abstract proxy requires that you specify the \ref OOLUA::Abstract
			"Abstract" tag in the \ref OOLUA_TAGS block
			\copydetails OOLUA::Abstract
			\snippet cpp_hierarchy.h CppAbstract1
			\snippet expose_hierarchy.h ExposeAbstract1
			\snippet expose_hierarchy.cpp ExportAbstract1

		\subsection BaseClass Base Classes
			Using \ref OOLUA_PROXY "OOLUA_PROXY's" optional parameter(s) specifies base 
			class(es) for the proxy
			\copydetails OOLUA_PROXY 
			\snippet cpp_hierarchy.h CppDerived1Abstract1
			\snippet expose_hierarchy.h ExposeDerived1Abstract1
			\snippet expose_hierarchy.cpp ExportDerived1Abstract1
			
		\subsection ClassOps Operators
			\copydetails OperatorTags
			\snippet cpp_class_ops.h CppClassOps
			\snippet lua_class_ops.h ClassOpsExpose
			\snippet lua_class_ops.cpp ClassOpsExport
			
		\subsection ClassPublicMembers Public Members
			\copydetails OOLUA_MGET
			\copydetails OOLUA_MSET
			\copydetails OOLUA_MGET_MSET
			\snippet cpp_public_instances.h CppPublicMembers
			\snippet expose_public_instances.h PublicMembersExpose
			\snippet expose_public_instances.cpp PublicMembersExport
			<p>
			<b>Public member access in Lua is via a member function</b>
			\snippet public_variables.cpp PublicMemberUsage

			
		\subsection ClassEnumerations Enumerations
			\copydetails OOLUA_ENUMS
			\copydetails OOLUA_ENUM
			\snippet cpp_enum.h CppClassEnum
			\snippet expose_enum.h ClassEnumExpose
			\snippet expose_enum.cpp ClassEnumExport
			\snippet enum_tests.cpp ClassEnumUsage
			
		\subsection ClassStaticFunctions Static Functions
			\copydetails OOLUA_SFUNC
			\snippet cpp_static_and_c_functions.h CppClassStaticFunctions
			\snippet expose_static_and_c_functions.h ClassStaticFunctionExpose
			\snippet expose_static_and_c_functions.cpp ClassStaticFunctionExport

		
	\section CFunctions C Functions
		\subsection CFunctionMinimalist Minimalist
		We have already seen the \ref OOLuaMinimalist version in the Hello Moon 
		example.
		\copybrief OOLUA_CFUNC \copydetails OOLUA_CFUNC 
		\snippet hello_moon.cpp HelloMoonCFuncAndProxy
		\snippet hello_moon.cpp HelloMoonCFuncAndProxyMinimalist
		\snippet hello_moon.cpp HelloMoonCFuncAndProxyMinimalistUsage
**/

/*
			\snippet cpp_member_function_calls.h FunctionCalls
			\snippet expose_member_function_calls.h ProxyFunctionCalls
			\snippet expose_member_function_calls.cpp ProxyFunctionCallsExport
*/


/*
	\section OOLuaCFunctionProxy Proxying a C Function
		\subsection CFunctionMinimalist Minimalist
			We have already seen the \ref OOLuaMinimalist version in the Hello Moon 
			example.
			\copybrief OOLUA_CFUNC \copydetails OOLUA_CFUNC 
			\snippet hello_moon.cpp HelloMoonCFuncAndProxy
			\snippet hello_moon.cpp HelloMoonCFuncAndProxyMinimalist
			\snippet hello_moon.cpp HelloMoonCFuncAndProxyMinimalistUsage
		
		\subsection CFunctionExpressive Expressive
			\copybrief OOLUA_C_FUNCTION \copydetails OOLUA_C_FUNCTION 
			When there are overloaded versions of a function such as
			\snippet hello_moon.cpp HelloMoonCFuncOverloaded
			Then it is not enough information for C++ to detect which version is wanted
			as there is ambiguity 
			\snippet hello_moon.cpp HelloMoonCFuncProxyExpressive
			\snippet hello_moon.cpp HelloMoonCFuncAndProxyExpressiveUsage
	

*/

